%
% Name :
%   gen_iono_grid_3d.m
%
% Purpose :
%   Generates ionospheric plasma density, collision frequency and irregularity
%   grid as a function of range and height using IRI. Gridded geomagnetic
%   field data (generated using IGRF) is also returned. The format of the
%   outputs is that required for input into the 3d raytracing engine.
%
% Calling sequence :
%   1. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag)
%
%   2. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag, profile_type)
%
%   3. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
%         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
%                          doppler_flag, profile_type)
%
% Inputs :
%   UT                - 5x1 array containing UTC date and time - year, month,
%                         day, hour, minute
%   R12               - scalar R12 index
%      R12 = 1 - 200 :  IRI is called with R12 (Zurich V1.0) input as the
%                       user specified yearly smoothed monthly median sunspot
%                       number.  
%      R12 = -1      :  IRI is called with ionospheric conditions (R12,
%                       IG12, and F10.7) read from file (ig_rz.dat) based on
%                       input epoch (UT) and may be historical or projected
%                       conditions (dependent on the epoch). 
%
%   iono_grid_parms   - 9x1 vector containing the parameters which define the
%                       ionospheric grid :
%           (1) geodetic latitude (degrees) start
%           (2) latitude step (degrees)
%           (3) number of latitudes
%           (4) geodetic longitude (degrees) start
%           (5) lonitude step (degrees)
%           (6) number of longitudes
%           (7) geodetic height (km) start
%           (8) height step (km)
%           (9) number of heights
%
%   geomag_grid_parms - 9x1 vector containing the parameters which define the
%                       geomagnetic grid :
%           (1) geodetic latitude (degrees) start
%           (2) latitude step (degrees)
%           (3) number of latitudes
%           (4) geodetic lonitude (degrees) start
%           (5) longitude step (degrees)
%           (6) number of longitudes
%           (7) geodetic height (km) start
%           (8) height step (km)
%           (9) number of heights
%
%   doppler_flag      - flag to indicate whether (=1) or not (=0) to generate
%                       necessary parameters for Doppler shift and spread
%                       calculations in the raytracing routines. NB turning
%                       this on will increase the time required to generate
%                       the ionosphere.
%
% Optional Inputs
%   profile_type      - specify how the ionospheric profiles (with height) are
%                       to be generated (default is 'iri') (see also Notes) :
%     'iri'  or 'iri2020'  = profiles are those generated by the IRI2020 model
%     'iri2016'            = profiles are those generated by the IRI2016 model
%     'iri2012'            = profiles are those generated by the IRI2012 model
%     'iri2007'            = profiles are those generated by the IRI2007 model
%     'firi' or 'firi2020' = profiles are those generated by the IRI2020 model
%                            using the FIRI data for heights below 120 km, with
%                            interpolation between FIRI and IRI F layer
%     'firi' or 'firi2016' = profiles are those generated by the IRI2016 model
%                            using the FIRI data for heights below 120 km, with
%                            interpolation between FIRI and IRI F layer
%
%   iri_options        - structure which specfies options for IRI2016 (see 
%                        iri2016.m for details). iri_options is ignored if a
%                        profile_type other than IRI2016 is specified.
%
% Outputs :
%   iono_pf_grid   - 3d grid (height vs lat. vs lon.) of ionospheric plasma
%                      frequency (MHz)
%   iono_pf_grid_5 - 3d grid (height vs lat. vs lon.) of ionospheric plasma
%                      frequency (MHz) 5 minutes later
%   collison_freq  - 3d grid (height vs lat. vs lon.) of ionospheric
%                      collision frequencies
%   Bx             - 3d grid of x component of geomagnetic field
%   By             - 3d grid of y component of geomagnetic field
%   Bz             - 3d grid of z component of geomagnetic field
%
% Notes:
%   1. If an iri2012 profile is requested, then iri2012 is called with the
%   following inputs: B0B1_model = 2 (B0 thickness and B1 shape parameters
%   determined by Bil-2000 model), D_model = 1 (IRI-1990 model for D layer).
%   See iri2012.m for further detail
%
%   2. If an iri2007 profile is requested, then iri2007 is called with the
%   following inputs: B0 - Table option, D-region model - IRI-1995. See
%   iri2007.m for further detail.

%
% Dependencies:
%   iri2020.mex
%   iri2016.mex
%   iri2012.mex
%   iri2007.mex
%   igrf2020.mex
%   solar_za.m
%
% Modification History:
%   V1.0  M.A. Cervera  25/06/2010
%     Initial Version
%
%   V1.1  M.A. Cervera  12/09/2012
%     Updated to use IRI2012 and IGRF2011
%
%   V1.2  M.A. Cervera  03/05/2016
%     Updated to use IRI2016 and IGRF2016
%
%   V1.3  M.A. Cervera  17/09/2018
%     Improved method for calculating the effective collision frequency using
%     electron and temperatures (from IRI) and density of neutral constituents
%     (from nrlmsise00). See e.g. Pederick and Cervera (2014), Radio Sci., 
%     vol. 49, 81--93, doi:10.1002/2013RS005274
%
%   V1.4  M.A. Cervera 06/06/2019
%     Removed the "Chapman" options. No longer required. Tidied up help.
%
%   V1.5  M.A. Cervera 24/02/2020
%     Minor update to collision frequency calculation. Now returns NaN below
%     altitudes where IRI returns valid electron and ion temperatures.
%
%   V1.6  M.A. Cervera 16/05/2023
%     Updated to now use IRI2020 and IGRF2020
%

function [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
                          doppler_flag, profile_type, varargin)


  pfsq_conv = 80.6163849431291e-12;  % mult. factor to convert electron density
                                     % in m^-3 to plasma freq. squared in MHz^2

  % get the iri_options structure if it has been input
  if (length(varargin) > 0) 
    iri_options = varargin{1};
  else
    iri_options = struct;
  end

  % make sure we have a valid profile type
  if (~exist('profile_type'))
    profile_type = 'iri';
  end
  if (~strcmp(lower(profile_type), 'iri') && ...
	~strcmp(lower(profile_type), 'firi') && ...
	~strcmp(lower(profile_type), 'iri2020')  & ...
	~strcmp(lower(profile_type), 'iri2016')  & ...
	~strcmp(lower(profile_type), 'iri2012') && ...
	~strcmp(lower(profile_type), 'iri2007') && ...
	~strcmp(lower(profile_type), 'firi2020') && ...
	~strcmp(lower(profile_type), 'firi2016') )
    error('invalid profile type')
    return
  end

  % ionospheric and geomagnetic grid definition
  lat_min = iono_grid_parms(1);
  lat_inc = iono_grid_parms(2);
  num_lat = iono_grid_parms(3);
  lon_min = iono_grid_parms(4);
  lon_inc = iono_grid_parms(5);
  num_lon = iono_grid_parms(6);
  ht_min = iono_grid_parms(7);
  ht_inc = iono_grid_parms(8);
  num_ht = iono_grid_parms(9);

  B_lat_min = geomag_grid_parms(1);
  B_lat_inc = geomag_grid_parms(2);
  B_num_lat = geomag_grid_parms(3);
  B_lon_min = geomag_grid_parms(4);
  B_lon_inc = geomag_grid_parms(5);
  B_num_lon = geomag_grid_parms(6);
  B_ht_min = geomag_grid_parms(7);
  B_ht_inc = geomag_grid_parms(8);
  B_num_ht = geomag_grid_parms(9);

  % initialize arrays
  iono_pf_grid = zeros(num_lat, num_lon, num_ht) .* NaN;
  iono_pf_grid_5 = zeros(num_lat, num_lon, num_ht) .* NaN;
  collision_freq = zeros(num_lat, num_lon, num_ht) .* NaN;
  Bx = zeros(B_num_lat, B_num_lon, B_num_ht);
  By = zeros(B_num_lat, B_num_lon, B_num_ht);
  Bz = zeros(B_num_lat, B_num_lon, B_num_ht);


  %
  % generate ionospheric grids
  %
  lat_max = lat_min + (num_lat - 1) .* lat_inc;
  lon_max = lon_min + (num_lon - 1) .* lon_inc;
  ht_max = ht_min + (num_ht - 1) .* ht_inc;
  height_arr = [ht_min : ht_inc : ht_max];
  lat_idx = 0;
  parfor lat_idx = 1:num_lat
    lat = lat_min + (lat_idx - 1) .* lat_inc;

    % generate ionosphere gridded in longitude and height
    [iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid] = ...
	gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ht_min, ht_inc, ...
  	                 ht_max, R12, UT, profile_type, doppler_flag, ...
	                 iri_options);

    % populate the ionospheric (lat,lon,height) grids
    iono_pf_grid(lat_idx, :, :) = iono_pf_subgrid;
    iono_pf_grid_5(lat_idx, :, :) = iono_pf_subgrid_5;
    collision_freq(lat_idx, :, :) = collision_freq_subgrid;

  end

  %
  % generate magnetic field grids
  %
  B_lat_max = B_lat_min + (B_num_lat - 1) .* B_lat_inc;
  B_lon_max = B_lon_min + (B_num_lon - 1) .* B_lon_inc;
  B_ht_max = B_ht_min + (B_num_ht - 1) .* B_ht_inc;
  parfor B_lat_idx = 1:B_num_lat
    lat = B_lat_min + (B_lat_idx - 1) .* B_lat_inc;

    % generate magnetic field gridded in longitude and height
    [Bx_subgrid, By_subgrid, Bz_subgrid] = ...
	gen_Bfield_subgrid(lat, B_lon_min, B_lon_inc, B_lon_max, ...
	                   B_ht_min, B_ht_inc, B_ht_max, UT);

    % populate the magnetic field (lat,lon,height) grids
    Bx(B_lat_idx, :, :) = Bx_subgrid;
    By(B_lat_idx, :, :) = By_subgrid;
    Bz(B_lat_idx, :, :) = Bz_subgrid;
  end

  return
end


%
% subfunction which generates geomagnetic field gridded over longitude and
% height for a given input latitude
%
function [Bx_subgrid, By_subgrid, Bz_subgrid] = ...
      gen_Bfield_subgrid(lat, B_lon_min, B_lon_inc, B_lon_max, B_ht_min, ...
                         B_ht_inc, B_ht_max, UT);
  
  lon_idx = 0;
  for lon = B_lon_min:B_lon_inc:B_lon_max
    lon_idx = lon_idx + 1;
    ht_idx = 0;
    for height = B_ht_min:B_ht_inc:B_ht_max
      ht_idx = ht_idx + 1;
      mag_field = igrf2020(lat, lon, UT, height);
      field_N = mag_field(1);
      field_E = mag_field(2);
      field_U = -mag_field(3);
      [field_x, field_y, field_z] = ENU2xyz(field_E, field_N, field_U, ...
	                                    lat, lon);
      Bx_subgrid(lon_idx, ht_idx) = field_x;
      By_subgrid(lon_idx, ht_idx) = field_y;
      Bz_subgrid(lon_idx, ht_idx) = field_z;
    end
  end

  return
end



%
% subfunction which generates ionospheric data gridded over longitude and
% height for a given input latitude
%
function [iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid] = ...
      gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ht_min, ht_inc, ...
                       ht_max, R12, UT, profile_type, doppler_flag, ...
                       iri_options);

  pfsq_conv = 80.6163849431291e-12;    % multiplicative factor to convert 
                                       % electron dens (m^3) to 
                                       % plasma freq. squared (MHz^2)

  height_arr = [ht_min : ht_inc : ht_max];
  lat_arr = ones(size(height_arr))*lat;

  % UT 5 minutes later
  UT_5 = UT + [0 0 0 0 5];
  if (UT_5(5) > 59)
    UT_5(5) = UT_5(5) - 60;
    UT_5(4) = UT_5(4) + 1;
    if (UT_5(4) > 23) UT_5(4) = 0; end
  end

  lon_idx = 0;
  for lon = lon_min:lon_inc:lon_max
    lon_idx = lon_idx + 1;
    lon_arr = ones(size(height_arr))*lon;

    %%%%%%%%%%%%%%%%%%%
    % This is IRI2020 %
    %%%%%%%%%%%%%%%%%%%
    if (strcmp(lower(profile_type), 'iri') | ...
	  strcmp(lower(profile_type), 'iri2020') )

      num_heights = round((ht_max - ht_min)/ht_inc) + 1;

      % call IRI2020
      [iono, iono_extra] = iri2020(lat, lon, R12, UT, ht_min, ht_inc, ...
	                           num_heights, iri_options);

      if doppler_flag
	[iono5, iono_extra5] = iri2020(lat, lon, R12, UT_5, ht_min, ht_inc, ...
	                               num_heights, iri_options);
      end

      % get the electron density (Num electrons per m^3)
      elec_dens = iono(1, :);
      idx_neg = find(elec_dens == -1);
      elec_dens(idx_neg) = 0;

      if doppler_flag
	elec_dens5 = iono5(1, :);
	idx_neg = find(elec_dens5 == -1);
	elec_dens5(idx_neg) = 0;
      end

      % calculate plasma frequency (MHz) profile and fill the array
      iono_pf_subgrid(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);    
      if doppler_flag
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens5 .* pfsq_conv);  
      else
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);
      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089);
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % This is IRI2020 with FIRI option on %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      elseif (strcmp(lower(profile_type), 'firi') | ... 
	         strcmp(lower(profile_type), 'firi2020') )

      num_heights = round((ht_max - ht_min)/ht_inc) + 1;

      % call IRI 2020, with FIRI option on
      [iono, iono_extra] = ...
	  iri2020_firi_interp(lat, lon, R12, UT, ht_min, ht_inc, ...
	                      num_heights, iri_options);

      if doppler_flag
	[iono5, iono_extra5] = ...
	    iri2020_firi_interp(lat, lon, R12, UT_5, ht_min, ht_inc, ...
	                        num_heights, iri_options);
      end

      % get the electron density (Num electrons per m^3)
      elec_dens = iono(1, :);
      idx_neg = find(elec_dens == -1);
      elec_dens(idx_neg) = 0;

      if doppler_flag
	elec_dens5 = iono5(1, :);
	idx_neg = find(elec_dens5 == -1);
	elec_dens5(idx_neg) = 0;
      end

      % calculate plasma frequency (MHz) profile and fill the array
      iono_pf_subgrid(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);     
      if doppler_flag
	iono_pf_subgrid_5(lon_idx, :) =  sqrt(elec_dens5 .* pfsq_conv);  
      else
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);
      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089); 
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);
    
    %%%%%%%%%%%%%%%%%%%
    % This is IRI2016 %
    %%%%%%%%%%%%%%%%%%%
    elseif (strcmp(lower(profile_type), 'iri2016') )

      num_heights = round((ht_max - ht_min)/ht_inc) + 1;

      % call IRI2016
      [iono, iono_extra] = iri2016(lat, lon, R12, UT, ht_min, ht_inc, ...
	                           num_heights, iri_options);

      if doppler_flag
	[iono5, iono_extra5] = iri2016(lat, lon, R12, UT_5, ht_min, ht_inc, ...
	                               num_heights, iri_options);
      end

      % get the electron density (Num electrons per m^3)
      elec_dens = iono(1, :);
      idx_neg = find(elec_dens == -1);
      elec_dens(idx_neg) = 0;

      if doppler_flag
	elec_dens5 = iono5(1, :);
	idx_neg = find(elec_dens5 == -1);
	elec_dens5(idx_neg) = 0;
      end

      % calculate plasma frequency (MHz) profile and fill the array
      iono_pf_subgrid(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);    
      if doppler_flag
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens5 .* pfsq_conv);  
      else
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);
      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089);
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % This is IRI2016 with FIRI option on %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    elseif strcmp(lower(profile_type), 'firi2016')

      num_heights = round((ht_max - ht_min)/ht_inc) + 1;

      % call IRI 2016, with FIRI option on
      [iono, iono_extra] = ...
	  iri2016_firi_interp(lat, lon, R12, UT, ht_min, ht_inc, ...
	                      num_heights, iri_options);

      if doppler_flag
	[iono5, iono_extra5] = ...
	    iri2016_firi_interp(lat, lon, R12, UT_5, ht_min, ht_inc, ...
	                        num_heights, iri_options);
      end

      % get the electron density (Num electrons per m^3)
      elec_dens = iono(1, :);
      idx_neg = find(elec_dens == -1);
      elec_dens(idx_neg) = 0;

      if doppler_flag
	elec_dens5 = iono5(1, :);
	idx_neg = find(elec_dens5 == -1);
	elec_dens5(idx_neg) = 0;
      end

      % calculate plasma frequency (MHz) profile and fill the array
      iono_pf_subgrid(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);     
      if doppler_flag
	iono_pf_subgrid_5(lon_idx, :) =  sqrt(elec_dens5 .* pfsq_conv);  
      else
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);
      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089); 
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);

    %%%%%%%%%%%%%%%%%%%
    % This is IRI2012 %
    %%%%%%%%%%%%%%%%%%%
    elseif (strcmp(lower(profile_type), 'iri2012') )

      num_heights = round((ht_max - ht_min)/ht_inc) + 1;

      % call IRI2012
      [iono, iono_extra] = iri2012(lat, lon, R12, UT, ht_min, ht_inc, ...
	                           num_heights);

      if doppler_flag
	[iono5, iono_extra5] = iri2012(lat, lon, R12, UT_5, ht_min, ht_inc, ...
	                               num_heights);
      end

      % get the electron density (Num electrons per m^3)
      elec_dens = iono(1, :);
      idx_neg = find(elec_dens == -1);
      elec_dens(idx_neg) = 0;

      if doppler_flag
	elec_dens5 = iono5(1, :);
	idx_neg = find(elec_dens5 == -1);
	elec_dens5(idx_neg) = 0;
      end

      % calculate plasma frequency (MHz) profile and fill the array
      iono_pf_subgrid(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);     % (MHz)
      if doppler_flag
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens5 .* pfsq_conv);  % (MHz)
      else
	iono_pf_subgrid_5(lon_idx, :) = sqrt(elec_dens .* pfsq_conv);
      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089);
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);
      
    %%%%%%%%%%%%%%%%%%%
    % This is IRI2007 %
    %%%%%%%%%%%%%%%%%%%
    elseif strcmp(lower(profile_type), 'iri2007')

      % IRI only returns 100 values for elecron density with height - so
      % determine the number of  multiple calls required.
      num_ht = (ht_max - ht_min) ./ ht_inc + 1; 
      max_iri_numhts = 100;
      num_iri_calls = ceil(num_ht ./ max_iri_numhts);
      for ii = 1:num_iri_calls

	% call IRI 2007
	height_start = ht_min + (ii - 1) .* max_iri_numhts .* ht_inc;
	[iono, iono_extra] = iri2007(lat, lon, R12, UT, height_start, ht_inc);
	if doppler_flag
	  [iono5, iono_extra5] = iri2007(lat, lon, R12, UT_5, height_start, ...
	                                 ht_inc);
	end

	% get the electron density (Num electrons per m^3)
	remaining_heights = num_ht - (ii - 1)*max_iri_numhts;
	idx_end = min([remaining_heights max_iri_numhts]);

	elec_dens = iono(1, 1:idx_end);
	idx_neg = find(elec_dens == -1);
	elec_dens(idx_neg) = 0;

	if doppler_flag
	  elec_dens5 = iono5(1, 1:idx_end);
	  idx_neg = find(elec_dens5 == -1);
	  elec_dens5(idx_neg) = 0;
	end

	% calculate plasma frequency (MHz) profile and fill the array
	ht_idx = [(ii - 1)*max_iri_numhts + 1 :  ...
	          ii*max_iri_numhts - (max_iri_numhts - idx_end)];
	iono_pf_subgrid(lon_idx, ht_idx) = sqrt(elec_dens .* pfsq_conv);
	if doppler_flag
	  iono_pf_subgrid_5(lon_idx, ht_idx) = sqrt(elec_dens5 .* pfsq_conv); 
	else
	  iono_pf_subgrid_5(lon_idx, ht_idx) = sqrt(elec_dens .* pfsq_conv);
	end

      end

      % electron and ion temperatures
      T_e = iono(4, :);
      T_e(T_e == -1) = NaN;
      %idx = find(T_e == -1);
      %if (~isempty(idx)) T_e(idx) = T_e(idx(end)+1); end

      T_ion = iono(3, :);
      T_ion(T_ion == -1) = NaN;
      %idx = find(T_ion == -1);
      %if (~isempty(idx)) T_ion(idx) = T_ion(idx(end)+1); end

      % neutral densities
      if (R12 == -1)
	[neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT);
      else
	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
	f107 = 63.75 + R12*(0.728 + R12*0.00089);
	[neutral_dens, temp] = ...
	    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4);
      end

      % calculate collision frequency
      collision_freq_subgrid(lon_idx, :) = ...
	  eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens);
      
    end

  end

  return
end